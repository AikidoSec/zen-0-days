const { test } = require("node:test");
const { equal } = require("node:assert");

test("Zen prevents path traversal", async () => {
  process.env.AIKIDO_BLOCK = "true";
  process.env.AIKIDO_DEBUG = "true";

  require("@aikidosec/firewall");

  const st = require("st");
  const path = require("path");
  const http = require("http");

  const mount = st({ path: path.join(__dirname, "/static"), url: "/" });

  const server = await new Promise((resolve) => {
    const _server = http
      .createServer((req, res) => {
        try {
          const stHandled = mount(req, res);
          if (!stHandled) {
            res.writeHead(404, { "Content-Type": "text/plain" });
            res.end("Not Found");
          }
        } catch (err) {
          res.writeHead(500, { "Content-Type": "text/plain" });
          res.end(err.message);
        }
      })
      .listen(3000, () => {
        resolve(_server);
      });
  });

  const response = await fetch("http://localhost:3000/test.txt");
  equal(response.status, 200);
  const text = await response.text();
  equal(text, "42");

  const response2 = await new Promise((resolve, reject) => {
    const req = http.request(
      {
        hostname: "localhost",
        port: 3000,
        path: "/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd", // Path traversal attempt
        method: "GET",
      },
      (res) => {
        let data = "";

        res.on("data", (chunk) => {
          data += chunk;
        });

        res.on("end", () => {
          resolve(data);
        });
      }
    );

    req.on("error", (err) => {
      reject(err);
    });

    req.end();
  });

  equal(
    response2,
    "Zen has blocked a path traversal attack: path.join(...) originating from url"
  );

  server.close();
});
