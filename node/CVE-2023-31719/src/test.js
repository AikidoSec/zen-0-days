const { spawn } = require("child_process");
const fetch = require("node-fetch");
const bcrypt = require("bcryptjs");

function startServer(enableZen) {
  console.log(`Starting server with Zen ${enableZen ? "enabled" : "disabled"}`);
  const env = {
    ...process.env,
    NODE_OPTIONS: enableZen ? "--require @aikidosec/firewall" : "",
  };

  const server = spawn("node", ["main.js"], {
    env,
    stdio: "inherit",
  });

  server.on("close", (code) => {
    console.log(`Server process exited with code ${code}`);
  });

  return server;
}

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

async function test(enableZen) {
  const server = startServer(enableZen);
  // Wait for the server to start
  await sleep(1000);

  const newPassword = "notthepassword";
  const newHash = await bcrypt.hash(newPassword, 10);

  // Send a request to the server
  const response = await fetch("http://127.0.0.1:1881/api/signin", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      username: `' UNION SELECT 'admin', 'ADMIN', '${newHash}', null --`,
      password: newPassword,
    }),
  });

  if (enableZen) {
    if (response.status !== 400) {
      throw new Error("Zen should have blocked the request");
    }
    const data = await response.json();
    console.log("Response data:", data);
    if (
      data.message !==
      "Error: Zen has blocked an SQL injection: sqlite3.all(...) originating from body.username"
    ) {
      throw new Error("Zen did not block the request as expected");
    }
  } else {
    if (response.status !== 200) {
      throw new Error(`Failed to sign in: ${response.status}`);
    }

    const data = await response.json();
    console.log("Response data:", data);
  }

  server.kill();
  // Wait for the server to exit
  await sleep(1000);
}

(async () => {
  await test(false); // Test with Zen enabled
  await test(true); // Test with Zen disabled
})();
