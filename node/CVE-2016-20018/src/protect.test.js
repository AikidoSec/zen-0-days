const { test } = require("node:test");
const { equal, rejects } = require("node:assert");
const { runWithContext } = require("@aikidosec/firewall/agent/Context");

test("Zen protects against SQL Injection", async () => {
  process.env.AIKIDO_BLOCK = "true";

  require("@aikidosec/firewall");

  const knex = require("knex")({
    client: "mysql2",
    connection: {
      host: "127.0.0.1",
      user: "root",
      password: "123456",
      database: "test",
      charset: "utf8",
    },
  });

  const exists = await knex.schema.hasTable("users");
  if (!exists) {
    await knex.schema.createTable("users", (table) => {
      table.increments("id").primary();
      table.string("name").notNullable();
      table.string("secret").notNullable();
    });
    await knex("users").insert({
      name: "admin",
      secret: "you should not be able to return this!",
    });
    await knex("users").insert({
      name: "guest",
      secret: "hello world",
    });
  }

  const attackerControlled = {
    name: "admin",
  };

  // This is done automatically by Zen for supported web frameworks (this is just a test)
  await runWithContext(
    {
      method: "GET",
      remoteAddress: "1.2.3.4",
      body: attackerControlled,
      url: "/test",
      headers: {},
      routeParams: {},
      query: {},
      cookies: {},
      source: "test",
      route: "/test",
    },
    async () => {
      console.log(
        await knex("users").select().where({ secret: attackerControlled })
      );
      /*await rejects(
        knex("users").select().where({ secret: attackerControlled }),
        {
          message:
            "Zen has blocked an SQL injection: MySQL.query(...) originating from query.test",
        }
      );*/
    }
  );
});
