const { test } = require("node:test");
const { equal, rejects } = require("node:assert");
const { runWithContext } = require("@aikidosec/firewall/agent/Context");

test("It protects", async () => {
  process.env.AIKIDO_BLOCK = "true";

  // Temporary fix against a bug in @aikidosec/firewall
  const FunctionCache = globalThis.Function;

  require("@aikidosec/firewall");

  globalThis.Function = FunctionCache;

  const Sequelize = require("sequelize");

  const sequelize = new Sequelize("mysql://root:123456@172.17.0.1:3306/test", {
    dialectOptions: {
      multipleStatements: true,
    },
  });

  const User = sequelize.define("User2", {
    username: Sequelize.STRING,
    password: Sequelize.STRING,
  });

  await sequelize.sync();

  await User.insertOrUpdate({
    username: "admin",
    password: "admin",
  });

  // This is done automatically by Zen for supported web frameworks (this is just a test)
  await runWithContext(
    {
      method: "GET",
      remoteAddress: "1.2.3.4",
      body: undefined,
      url: "/test",
      headers: {},
      routeParams: {},
      query: {
        test: "DELETE FROM User2s;",
      },
      cookies: {},
      source: "test",
      route: "/test",
    },
    async () => {
      await rejects(
        User.findAndCountAll({
          order: [["id", "DESC; DELETE FROM User2s;"]],
        }),
        {
          message:
            "Zen has blocked an SQL injection: MySQL.query(...) originating from query.test",
        }
      );
    }
  );

  const result = await User.findAndCountAll();
  equal(result.count > 0, true);

  await sequelize.close();
});
